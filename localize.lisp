(in-package :cl-meld)

(define-condition localize-invalid-error (error)
   ((text :initarg :text :reader text)))
   
(defun get-second-arg (subgoal) (second (subgoal-args subgoal)))
(defun get-first-arg (subgoal) (first (subgoal-args subgoal)))

(defun is-route-p (def)
   (with-definition def (:types typs :options opts)
      (and (>= (length typs) 2)
           (type-addr-p (second typs))
           (has-elem-p opts :route))))
(defun get-routes (code)
   (mapfilter #'definition-name #'is-route-p (definitions code)))
(defun get-paths (subgoals routes)
   (filter #L(has-test-elem-p routes (subgoal-name !1) #'string-equal) (get-subgoals subgoals)))

(defun equal-to-any-home (arg homes) (some #L(var-eq-p arg !1) homes))
(defun select-subgoals-by-home (subgoals home-vars)
   (filter #L(equal-to-any-home (get-first-arg !1) home-vars) (get-subgoals subgoals)))

(defun generate-args (n typs)
   (mapcar #L(make-var (concatenate 'string "X" (write-to-string !2)) !1) typs (enumerate 0 (1- n))))
(defun generate-inverse-name (name) (concatenate 'string "___" (reverse name)))
(defun swap-first-two-args (args) `(,(second args) ,(first args) ,@(rest (rest args))))   
(defun change-first-arg (args first) `(,first ,@(rest args)))

(defparameter *name-counter* 0)
(defun generate-mangled-name ()
   (with-output-to-string (a) (format a "__mangledname~a" (incf *name-counter*))))

(defun create-inverse-routes (code routes)
   (dolist (route routes)
      (let* ((new-name (generate-inverse-name route))
             (old-definition (lookup-definition-types (definitions code) route))
             (new-definition (make-definition new-name old-definition :route `(:reverse-route ,route)))
             (args (generate-args (length old-definition) old-definition))
             (new-clause (make-clause `(,(make-subgoal route args))
                     `(,(make-subgoal new-name (swap-first-two-args args))) `(:route ,(var-name (second args))))))
         (push new-clause (clauses code))
         (push new-definition (all-definitions code)))))
         
(defun select-valid-constraints (body vars) (filter #L(subsetp (all-variable-names !1) vars) (get-constraints body)))
(defun generate-inverse-subgoal (new-name to needed-vars)
   (make-subgoal new-name `(,to ,@needed-vars)))
                  
(defun match-paths (sources) #'(lambda (path) (some #L(equal !1 (first path)) sources)))
(defun expand-sources (sources paths) (mapfilter #'second (match-paths sources) paths))
(defun decrease-paths (sources paths) (remove-if (match-paths sources) paths))
(defun host-node (head) (first (subgoal-args (first head))))
                  
(defun check-valid-paths (paths0 host0)
   (let ((paths (mapcar #L(list (var-name (first (subgoal-args !1)))
                                (var-name (second (subgoal-args !1)))) paths0))
          (rm `(,(var-name host0))))
      (loop while paths
            for expand = (expand-sources rm paths)
            do (unless expand (error 'localize-invalid-error :text "Invalid paths in clause"))
               (setf paths (decrease-paths rm paths))
               (setf rm expand))))
               
(defun variables-defined (body)
   (with-ret ret
      (do-assignments body (:var var) (push-dunion var ret))
      (do-subgoals body (:args args)
         (dolist (arg args)
            (when (var-p arg)
               (push-dunion arg ret))))))
               
(defun variables-undefined0 (head body)
   (with-ret ret
      (push-dunion-all (all-variables head) ret)
      (do-constraints body (:expr expr)
         (push-dunion-all (all-variables expr) ret))
      (do-subgoals body (:args args)
         (dolist (arg args)
            (unless (var-p arg)
               (push-dunion-all (all-variables arg) ret))))))
                     
(defun variables-undefined (head body)
   (set-tree-difference (variables-undefined0 head body) (variables-defined body)))
         
(defun can-be-reached-by (current-homes)
   #'(lambda (path)
      (some #'(lambda (home) (var-eq-p (get-first-arg path) home)) current-homes)))   
(defun reachable-paths (to paths)
   (loop with current = `(,to)
         for next-paths = (filter (can-be-reached-by current) paths)
         while next-paths
         do (push-all (mapcar #'get-second-arg next-paths) current)
         do (setf paths (remove-all paths next-paths))
         finally (return current)))
(defun get-next-paths (paths host) (mapfilter #'get-second-arg (can-be-reached-by `(,host)) paths))

(defun do-localize-one (code clause to route-subgoal remaining)
   (let* ((reachable (reachable-paths to remaining))
          (subgoals (select-subgoals-by-home (clause-body clause) reachable)))
      (unless subgoals
         (return-from do-localize-one nil))
      (let* ((new-fact-name (generate-mangled-name)) (body (clause-body clause)) (head (clause-head clause))
             (new-routing (make-subgoal (generate-inverse-name (subgoal-name route-subgoal))
                            (swap-first-two-args (subgoal-args route-subgoal))))
             (premisses `(,new-routing ,@subgoals))
             (assignments (select-valid-assignments body subgoals))
             (constraints (select-valid-constraints body (all-variable-names `(,@premisses ,@assignments))))
             (stripped-body (remove-all body `(,route-subgoal ,@subgoals ,@constraints ,@assignments)))
             (everything-else `(,new-routing ,@stripped-body))
             (new-clause-body `(,@subgoals ,new-routing ,@assignments ,@constraints))
             (variables-undef (variables-undefined head everything-else))
             (variables-subgoals (variables-defined new-clause-body))
             (needed-vars (tree-intersection variables-subgoals variables-undef))
             (new-subgoal (generate-inverse-subgoal new-fact-name (first (subgoal-args route-subgoal)) needed-vars)))
         (setf (clause-body clause) (remove-unneeded-assignments `(,new-subgoal ,@stripped-body) head))
         (push (make-definition (subgoal-name new-subgoal)
                  `(:type-addr ,@(mapcar #'expr-type needed-vars)) `(:routed-tuple)) (all-definitions code))
         (let ((new-clause-head `(,(copy-tree new-subgoal))))
            (make-clause (remove-unneeded-assignments new-clause-body new-clause-head) new-clause-head
                  `(:route ,(var-name (first (subgoal-args route-subgoal) ))))))))
            
(defun do-localize (code clause edges remaining)
   (dolist (edge edges)
      (let* ((to (get-second-arg edge))
             (new-clause (do-localize-one code clause to edge remaining))
             (new-edges (filter (edges-equal-to to) remaining))
             (new-remaining (remove-if (edges-equal-to to) remaining)))
         (when new-clause
            (push new-clause (clauses code))
            (when new-edges
               (do-localize code new-clause new-edges new-remaining))))))

(defun edges-equal-to (host) #L(var-eq-p host (get-first-arg !1)))
(defun localize-start (code clause routes host)
   (let ((paths (get-paths (clause-body clause) routes)))
      (unless paths
         (return-from localize-start))
      (check-valid-paths paths host)
      (let ((edges (filter (edges-equal-to host) paths))
            (remaining (remove-if (edges-equal-to host) paths)))
         (do-localize code clause edges remaining))))
      
(defun localize-check-head (head)
   (let ((home (host-node head)))
      (do-subgoals (rest head) (:args args)
         (unless (var-eq-p (first args) home)
            (error 'localize-invalid-error
               :text "All head subgoals must have the same home argument")))))

(defun remove-home-argument (code)
   (do-clauses (clauses code) (:head head :body body)
      (let (head-var (host-id (make-host-id)))
         (do-subgoals (append body head)
                     (:args args :orig sub)
            (unless head-var (setf head-var (first args)))
            (setf (subgoal-args sub) (rest args)))
         (when head ; change home argument to host-id
            (nsubst host-id head-var head :test #'equal)
            (nsubst host-id head-var body :test #'equal)))) 
   (do-definitions code (:definition def :types typs)
      (setf (definition-types def) (rest typs))))

(defun localize (code)
   (let ((routes (get-routes code)))
      (do-clauses (clauses code) (:clause clause :head head)
         (localize-check-head head)
         (localize-start code clause routes (host-node head)))
      (create-inverse-routes code routes))
   (remove-home-argument code)
   code)
