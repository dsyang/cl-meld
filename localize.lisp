(in-package :cl-meld)

(define-condition localize-invalid-error (error)
   ((text :initarg :text :reader text)))

(defun get-routes (code)
   (mapfilter #'definition-name #L(has-elem-p (definition-options !1) :route) (definitions code)))
(defun get-paths (subgoals routes)
   (filter #L(has-test-elem-p routes (subgoal-name !1) #'string-equal) (get-subgoals subgoals)))
            
(defun select-subgoals-by-home (subgoals home-var)
   (filter #L(var-eq-p (first (subgoal-args !1)) home-var) (get-subgoals subgoals)))

(defun generate-args (n typs)
   (mapcar #L(list :var (concatenate 'string "X" (write-to-string !2)) !1) typs (enumerate 0 (1- n))))
(defun generate-inverse-name (name) (concatenate 'string "___" (reverse name)))
(defun swap-first-two-args (args) `(,(second args) ,(first args) ,@(rest (rest args))))   
(defun change-first-arg (args first) `(,first ,@(rest args)))

(defparameter *name-counter* 0)
(defun generate-mangled-name ()
   (with-output-to-string (a)
      (format a "mangledname~a" (incf *name-counter*))))

(defun create-inverse-routes (code routes)
   (dolist (route routes)
      (let* ((new-name (generate-inverse-name route))
             (old-definition (lookup-definition (definitions code) route))
             (new-definition (make-definition new-name old-definition :route `(:reverse-route ,route)))
             (args (generate-args (length old-definition) old-definition))
             (new-clause (make-clause `(,(make-subgoal route args)) `(,(make-subgoal new-name (swap-first-two-args args))) :route)))
         (push new-clause (clauses code))
         (push new-definition (definitions code)))))
         
(defun select-valid-constraints (body vars) (filter #L(subsetp (all-variable-names !1) vars) (get-constraints body)))
(defun generate-inverse-subgoal (subgoal new-name to)
   (make-subgoal new-name (change-first-arg (subgoal-args subgoal) to)))
                  
(defun match-paths (sources) #'(lambda (path) (some #L(equal !1 (first path)) sources)))
(defun expand-sources (sources paths) (mapfilter #'second (match-paths sources) paths))
(defun decrease-paths (sources paths) (remove-if (match-paths sources) paths))
(defun host-node (head) (first (subgoal-args (first head))))
                  
(defun check-valid-paths (paths0 host0)
   (let ((paths (mapcar #L(list (var-name (first (subgoal-args !1)))
                                (var-name (second (subgoal-args !1)))) paths0))
          (rm `(,(var-name host0))))
      (loop while paths
            for expand = (expand-sources rm paths)
            do (unless expand (error 'localize-invalid-error :text "Invalid paths in clause"))
               (format t "EXPANDED from ~A to ~A ~%" rm expand)
               (setf paths (decrease-paths rm paths))
               (setf rm expand))))

(defun do-localize (code clause routes host)
   (let ((paths (get-paths (clause-body clause) routes)))
      (check-valid-paths paths host)
      (with-var ret
         (dolist (path paths)
            (let* ((subgoals (select-subgoals-by-home (clause-body clause) (second (subgoal-args path)))))
               (do-subgoals subgoals (:orig sub)
                  (let* ((new-fact-name (generate-mangled-name))
                        (new-routing (make-subgoal (generate-inverse-name (subgoal-name path))
                                          (swap-first-two-args (subgoal-args path))))
                        (to (first (subgoal-args path)))
                        (premisses0 (list new-routing sub))
                        (constraints (select-valid-constraints (clause-body clause) (all-variable-names premisses0)))
                        (inverse-sub (generate-inverse-subgoal sub new-fact-name to)))
                     (push (make-definition (subgoal-name inverse-sub)
                                             (lookup-definition (definitions code) (subgoal-name sub)) `(:inverse-tuple ,(subgoal-name sub))) (definitions code))
                     (push (make-clause `(,sub ,new-routing ,@constraints) `(,inverse-sub) :route) ret)
                     (setf (clause-body clause)
                        `(,inverse-sub ,@(remove-all (clause-body clause) `(,sub ,path ,@constraints))))))))
         ret)))
      
(defun localize-check-head (head)
   (let ((home (host-node head)))
      (do-subgoals (rest head) (:args args)
         (unless (var-eq-p (first args) home)
            (error 'localize-invalid-error
               :text "All head subgoals must have the same home argument")))))

(defun localize (code)
   (with-var new-clauses
      (let ((routes (get-routes code)))
         (do-clauses code (:clause clause :head head)
            (localize-check-head head)
            (push-all (do-localize code clause routes (host-node head)) new-clauses))
         (create-inverse-routes code routes)
         (push-all new-clauses (clauses code))))
   code)
   