(in-package :cl-meld)

(defun print-val (val &optional (hide-pars nil))
   (cond
      ((var-p val) (tostring "~a" (var-name val)))
      ((int-p val) (tostring "~A" (int-val val)))
      ((float-p val) (tostring "~A" (float-val val)))
      ((host-id-p val) (tostring "host"))
      ((world-p val) (tostring "world"))
      ((addr-p val) (tostring "@~a" (addr-num val)))
      ((convert-float-p val)
         (tostring "float(~a)" (print-val (convert-float-expr val))))
      ((cons-p val)
         (tostring "cons(~a,~a)" (print-val (cons-head val)) (print-val (cons-tail val))))
      ((tail-p val)
         (tostring "tail(~a)" (print-val (tail-list val))))
      ((head-p val)
         (tostring "head(~a)" (print-val (head-list val))))
      ((nil-p val) (tostring "nil"))
      ((test-nil-p val)
         (tostring "test-nil(~a)" (print-val (test-nil-expr val))))
      ((not-p val)
         (tostring "not(~a)" (print-val (not-expr val))))
      ((op-p val)
         (tostring "~a~a ~a ~a~a"
            (if hide-pars "" "(")
            (print-val (op-op1 val))
            (op-to-string (op-op val))
            (print-val (op-op2 val))
            (if hide-pars "" ")")))
      (t
         (error 'expr-invalid-error :text (tostring "Can't print expression ~a" val)))))
   
(defun print-args (args)
   (format t "(")
   (dolist-count (arg args id)
      (if (> id 1)
         (format t ","))
      (format t "~a" (print-val arg t)))
   (format t ")"))
   
(defparameter *current-print-level* 0)
(defparameter *max-print-level* 4)

(defmacro check-print-level ()
   `(cond
      ((= *current-print-level* *max-print-level*)
         (setf *current-print-level* 0)
         (format t "~a~a~a~a" #\Newline #\Tab #\Tab #\Tab))
      (t (incf *current-print-level*))))
      
(defmacro reset-print-level ()
   `(setf *current-print-level* 0))
   
(defun print-subgoals (subgoals)
   (do-subgoals subgoals (:name name :args args :id id)
      (if (> id 1)
         (format t ", "))
      (check-print-level)
      (format t "~A" name)
      (print-args args)))
      
(defun print-constraints (subgoals)
   (do-constraints subgoals (:expr expr :id id)
      (if (> id 1)
         (format t ", "))
      (check-print-level)
      (format t "~a" (print-val expr t))))
      
(defun print-assignments (subgoals)
   (do-assignments subgoals (:var var :expr expr :id id)
      (if (> id 1)
         (format t ", "))
      (check-print-level)
      (format t "~a" (print-val var t))
      (format t " = ")
      (format t "~a" (print-val expr t))))
      
(defun print-type (typ)
   (cond
      ((type-int-p typ) "int")
      ((type-float-p typ) "float")
      ((type-addr-p typ) "addr")
      ((type-list-int-p typ) "list int")
      (t (error 'expr-invalid-error :text (tostring "print-type does not know how to handle ~a" typ)))))
      
(defun print-types (typs)
   (reduce #'(lambda (all new)
               (let ((typ (print-type new)))
                  (if (string-equal all "")
                     typ
                     (tostring "~a, ~a" all typ))))
                  typs :initial-value ""))
      
(defun print-program (code)
   (format t "I found the following definitions:~%")
   (do-definitions code (:name name :types typs)
      (format t "~A [~A]~%" name (print-types typs)))
   (format t "I found the following clauses:~%")
   (do-clauses (clauses code) (:head head :body body :id id)
      (format t "Clause ~A: " id)
      (print-subgoals head)
      (format t " :- ")
      (reset-print-level)
      (print-subgoals body)
      (when (has-assignments-p body)
         (format t ", ")
         (print-assignments body))
      (when (has-constraints-p body)
         (format t ", ")
         (print-constraints body))
      (format t "~%")))